# Overview

This is a Telegram bot-based shop system built with Python and Aiogram 3.x that enables automated cryptocurrency and fiat payment processing for digital goods sales, specifically optimized for **Telegram Stars purchases** with configurable markup. The bot supports multiple payment methods (QIWI, YooMoney, CryptoBot), automated inventory management, user transactions, and administrative controls. It's designed as a complete e-commerce solution within Telegram's messaging platform.

## Recent Changes (2025-10-19)

### Stars Markup System
- ✅ Added configurable markup percentage for Telegram Stars purchases
- ✅ Admin menu for managing Stars markup (0-100%)
- ✅ Automatic calculation of final price with markup display
- ✅ Commission automatically retained on CryptoBot balance
- ✅ Real-time price display showing base amount, markup, and total

### Database Updates
- Added `stars_markup` field to `storage_settings` table (default: 10%)
- Automatic migration for existing databases

### New Features
- **Stars Markup Menu**: `⚙️ Настройки` → `⭐ Наценка на звезды`
- **Transparent Pricing**: Users see base amount, markup percentage, and total before payment
- **Automated Commission**: Markup difference stays on CryptoBot balance as admin commission

### Documentation
- Created comprehensive `STARS_SETUP.md` with setup instructions
- Updated `CRYPTOBOT_SETUP.md` with Stars integration details
- Added `.gitignore` for Python project best practices

# User Preferences

Preferred communication style: Simple, everyday language.

# System Architecture

## Core Framework & Bot Implementation

**Problem:** Need a robust, asynchronous Telegram bot framework for handling e-commerce operations  
**Solution:** Aiogram 3.2.0 with async/await patterns throughout  
**Rationale:** Aiogram 3.x provides modern async support, built-in FSM (Finite State Machine) for conversational flows, and clean middleware architecture. The async nature allows handling multiple payment checks and user interactions concurrently without blocking.

## Database Architecture

**Problem:** Persistent storage for users, products, transactions, and settings  
**Solution:** SQLite with custom ORM-like wrapper using Pydantic models  
**Rationale:** 
- SQLite provides zero-configuration embedded database
- Pydantic models ensure type safety and validation
- Custom wrapper (`db_helper.py`) provides clean abstraction over raw SQL
- Separate model files for each entity (users, categories, positions, items, purchases, refills, payments, settings)

**Schema Design:**
- `storage_users` - User profiles and balances
- `storage_category` - Product categories hierarchy
- `storage_position` - Product listings with pricing
- `storage_item` - Individual inventory items (sold separately)
- `storage_purchases` - Purchase history and receipts
- `storage_refill` - Balance top-up transactions
- `storage_payment` - Payment gateway credentials
- `storage_settings` - Bot configuration and feature toggles

## Payment Gateway Integrations

**Problem:** Accept multiple payment methods with different APIs  
**Solution:** Abstracted payment service layer with dedicated API classes

**Payment Processors:**
1. **QIWI Wallet** (`api_qiwi.py`)
   - API-based payment verification
   - Balance checking
   - Transaction history

2. **YooMoney** (`api_yoomoney.py`)
   - OAuth token authentication
   - Payment link generation
   - Status polling

3. **CryptoBot** (`api_cryptobot.py`)
   - Cryptocurrency payments (BTC, ETH, USDT, TON)
   - Invoice creation via Crypto Pay API
   - Real-time payment verification

**Design Pattern:** Each payment class follows similar interface:
- Token/credentials management
- Balance checking methods
- Payment creation
- Status verification
- Error handling with admin notifications

## State Management

**Problem:** Multi-step user interactions (product selection, payment flow, admin operations)  
**Solution:** Aiogram FSM (Finite State Machine) with custom state handling  
**Implementation:**
- States stored in `FSMContext`
- State data persisted across handler calls
- Clear state transitions for different workflows
- Automatic state cleanup on completion

## Middleware Architecture

**Anti-Spam Protection** (`middleware_throttling.py`):
- TTL-based cache (10,000 users, 10-minute expiry)
- Dynamic rate limiting with progressive delays
- Per-user throttling counters

**User Management** (`middleware_users.py`):
- Automatic user registration on first interaction
- Profile updates (username, display name)
- HTML sanitization for user inputs

## Routing & Handler Organization

**Structure:**
- Separate routers for admin and user functionality
- Admin routes protected by `IsAdmin` filter
- Feature-based route grouping:
  - `admin_menu.py` - Admin dashboard
  - `admin_payment.py` - Payment system configuration
  - `admin_products.py` - Inventory management
  - `user_menu.py` - User interface
  - `user_transactions.py` - Payment processing

## Scheduled Tasks

**Problem:** Automated maintenance and statistics  
**Solution:** APScheduler with cron-based jobs  
**Jobs:**
- Daily profit reporting (00:00:15)
- Weekly statistics reset (Monday 00:00:10)
- Monthly counter updates (1st day 00:00:05)
- Automatic database backups (daily 00:00)
- Update checks (daily 00:00)
- Email notifications (daily 12:00)

## Keyboard System

**Two-Layer Interface:**
1. **Reply Keyboards** (`reply_main.py`)
   - Main menu navigation
   - Context-aware buttons (admin vs user)
   - Payment system selection

2. **Inline Keyboards** (`inline_*.py`)
   - Paginated product browsing
   - Payment confirmation
   - Admin controls
   - Dynamic callback data with state preservation

**Pagination Pattern:**
- 10 items per page
- Forward/backward navigation
- Jump to first/last page
- State preservation via callback data

## Error Handling & Logging

**Logging System:**
- Dual output: file (`logs.log`) + colored console
- Structured format with timestamps, file locations, line numbers
- Exception tracking in error handlers

**Error Recovery:**
- Telegram API error suppression (message edit conflicts)
- Payment gateway failure notifications to admins
- Graceful degradation for missing data

## Security Considerations

**Input Sanitization:**
- HTML tag stripping for user-generated content
- SQL injection prevention via parameterized queries
- Admin-only access controls

**Credential Storage:**
- Payment tokens stored in database
- No hardcoded secrets
- Token validation before enabling payment methods

# External Dependencies

## Payment Gateways

**QIWI Wallet API**
- Purpose: Russian payment system integration
- Authentication: API token + phone number
- Features: Balance checking, payment verification

**YooMoney API**
- Purpose: Russian digital wallet payments
- Authentication: Bearer token (OAuth)
- Endpoint: `https://yoomoney.ru/api/`

**CryptoBot (Crypto Pay API)**
- Purpose: Cryptocurrency payment processing
- Authentication: API token header (`Crypto-Pay-API-Token`)
- Endpoint: `https://pay.crypt.bot/api/`
- Supported currencies: BTC, ETH, USDT, TON, and others

## Core Libraries

**Aiogram 3.2.0**
- Telegram Bot API framework
- Async/await support
- Built-in FSM and middlewares

**APScheduler 3.9.1**
- Cron-based task scheduling
- Timezone support (Europe/Moscow)

**aiohttp 3.9.1**
- Async HTTP client for payment API calls
- Session pooling via `AsyncRequestSession`

**Pydantic 2.5.2**
- Data validation
- Database model definitions

**SQLite**
- Embedded database (via Python sqlite3)
- File-based storage at `tgbot/data/database.db`

## Utility Libraries

- **colorlog** - Colored console logging
- **beautifulsoup4** - HTML parsing/cleaning
- **aiofiles** - Async file operations
- **cachetools** - TTL cache for throttling
- **pytz** - Timezone handling